#### levels of Abstractions 
1. Hardware (physical Level) 
2. Microcode (firmware)
3. Machine code (opcodes)
4. Low-level Language (Disassembly )
5. High-level Language (C,C++,PASCAL turned into Machine codes )
6. Interpreted Languages (Perl,C# code translated into byetcode)



#### Reverse Engineering 

take malware binary as input and generate assembly language code as output with disassembly (IDA Pro) 


#### x86 Arcgutecture 

* CPU (contains control units get execute instruction from register in RAM)
* RAM (Stack , HEAP , Code , Data)
1. Data [contains values where program is initially loaded]
2. Code [ instructions fetched by CPU to execute program tasks]
3. Heap [ dynamic memory during program execution ] 
4. Stack [ local variables , parameters to controle program flow] 

* input/output 

#### instructions 
is made of mnemonic and zero or more operand

| Mnemonic      | Des Operand   |Source Operand  | 
| ------------- |:-------------:|---------------:|
mov            |   ecx         | 0x42           |

* opcodes and Endianness

| instruction   | mov ecx       | 0x42           |
| ------------- |:-------------:|---------------:|
| Opcodes       | B9            | 42 00 00 00      


#### registers 
small mount of data storage available to the CPU , whose contents can accessed more quickly

|General registers|Segment registers|instruction Pointer| 
| ----------------|:---------------:|------------------:|
|EAX              |  CS             | EIP               | 
|EBX              |  SS             |
|ECX              |  DS             |
|EDX              |  ES             |
|EBP              |  FS             |
|ESP              |  Gs             |
|ESI              |

#### Simple Instructions 

|instruction      | Description                     |
| ----------------|:-------------------------------:|
|mov eax,ebx      | copies content from ebx into eax|
|mov eax , 0x42   | copies all values 0x42 into EAX |
|mov eax ,[0x4037c4]| copy 4 bytes at memory location 0x4037c4 into eax| 
|mov eax ,[ebx]   | copies that 4 bytes into memory location specified by EBX|
|mov eax , [ebx+esi*4] | copies 4 bytes at memory location specified by result of equation ebx+esi*4 into EAX resgister|
|sub eax , 0x10 | subtractx 0x10 from EAX |
|add eax , ebx | adds EBX to EAX and stores results in EAX | 
|inc edx       | increments EDX by 1 | 
|dec ecx       | decrements ECX by 1 |
|mul 0x50      | multiplies EAX by 0x50 and stores results in EDX:EAX |
|div 0x75      | divides EDX:EAX by 0x75 and stores result in EAX |

### logical and shifting instructions 

* logical operators ( OR , AND , XOR ) [ perform specific operation between source and destination and store results at destination]
* Shifting (shr , shl ) [ multiplications as optimization ]

|instruction      | Description                     |
| ----------------|:-------------------------------:|
| xor eax , eax   | clears the EAX register |
| or eax , 0x7575 | logical operation on EAX with 0x7575|
|mov bl , 0xa     | rotates BL register to the right 2 bits |

#### conditional instructions 
* test , CMP 

#### Branching 
* jmp ( jump instructions ) 

|instruction      | Description                     |
| ----------------|:-------------------------------:|
| jz loc          | jump into specified location if ZF =1 | 
| jnz loc         | jump into specified location if ZF =0 |


#### rep instructions 
set of instructions for manipulation data buffers 
( movsx , cmpsx , stosx , scasx ) 

|instruction      | Description                     |
| ----------------|:-------------------------------:|
|repe cmpsb       | compare two data buffer |
|rep stosb        | initialize all bytes of a buffer to certain value | 
|rep movsb        | copy buffer of bytes (ESI > EDI )|
|repne scasb      | searching a data buffer for a signle byte |

